// Bi-TripCo by Nick Stavrou
// Bi-Fuel (LPG + Unleaded) Trip Computer
// Metric version
// Arduino UNO, 0.96" OLED display and DS3231 RTC module
// Release date: 29 Mar 2017
// Details can be found at www.instructables.com

// Libraries
#include "PinChangeInterrupt.h" // enables the interrupts at the other pin except the ones at the digital pins 2 and 3
#include <avr/sleep.h>          // enables the sleep function
#include <avr/power.h>          // power management
#include <EEPROMex.h>           // enables some special functions for writing to and reading from EEPROM
#include <EEPROMVar.h>
#include <Wire.h>               // IIC LIBRARY
#include "RTClib.h"             // Real Time Clock Library
#include <math.h>               // enables complex math functions
#include <Adafruit_SSD1306.h>   // library for the OLED and graphics
#include <Adafruit_GFX.h>

#define OLED_RESET 4
Adafruit_SSD1306 display(OLED_RESET);

RTC_DS3231 rtc;

// variables declaration
volatile static float vss_pulse_distance = 0.0002371173;  // distance coefficient -- change this according to your measurements (km/pulse)
volatile float LPG_injector_flow;                         // LPG injector flow coef. -- it is calculated at setup() (litres/microseconds)
volatile static float unleadedFlow = 4000e-12;            // gasoline injector flow coef. -- change this according to your measurements (litres/microseconds)

byte LPG1, LPG2, LPG3, LPG4, digitLPG, pos = 0;
volatile unsigned long vss_pulses;
volatile float traveled_distance, traveled_distance2, traveled_distance3, traveled_distance4, seconds_passed, speed, avg_speed, distance_to_LPGstation, distance_per_sec;
volatile float used_LPG, used_LPG2, instant_LPG_consumption, avg_LPG_consumption, LPG_in_tank, Full_tank = 45.00; //Full_tank: put your LPG Tank capacity
volatile float  srednieLPG , chwilowe, dystans, sredniePB, zasieg, zostaloLPG, poziomLPG;
volatile float used_Unleaded, used_Unleaded2;
volatile float average_L_100km_Unlead;

volatile unsigned long unleadTime1 = 0, unleadTime2 = 0, unleadinj_Open_Duration = 0;
volatile unsigned long LPG_injector_open_duration = 0, injTime1 = 0, injTime2 = 0;
int postemp;
int vss_pin = 2; // VSS signal input at digital pin 2 (INT0)
int LPG_pin = 3; // LPG injector signal input at digital pin 3 (INT1)
int ignition_pin = 9; // ignition signal input
int unleaded_pin = 12; // Unleaded injector signal input
int analogPin = A3; // poziom paliwa
float tempC;


boolean buttonState, buttonState2; // variables related to buttons functions
boolean lastButtonState2 = HIGH;
long lastDebounceTime = 0, logohold, counter, counter2;
volatile boolean ignition = false; // true od Marcina Kaminskiego
boolean ignoreRelease = false;
boolean inst_disp = true;
byte menunumber = 0,  menunumbermax = 10;
int h = 0, m = 0, s, m1;
boolean timeRead = false, displaychange = true;
float thermReading, steinhart;
boolean dots = true;
//int poziom = 0;
int temperatura;


//Below are the variables declaration for the thermistor -- you can find more info at: https://learn.adafruit.com/thermistor/using-a-thermistor
#define THERMISTORPIN A0
#define THERMISTORNOMINAL 10000
#define TEMPERATURENOMINAL 25

#define NUMSAMPLES 5
#define BCOEFFICIENT 3630
#define SERIESRESISTOR 10000
int samples[NUMSAMPLES];
int i = 0;

//below are the graphics used
const unsigned char leaf [] PROGMEM = {
0x00, 0x00, 0x07, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x07, 0xFF, 0xFF, 0x00, 0x3F, 0xFC, 0x1E,
0x00, 0xFF, 0x80, 0x1C, 0x01, 0xFC, 0x00, 0x3C, 0x07, 0xF0, 0x00, 0x38, 0x0F, 0xC0, 0x00, 0x38,
0x1F, 0x00, 0x00, 0x70, 0x1E, 0x00, 0x00, 0x70, 0x3C, 0x00, 0x80, 0x70, 0x38, 0x03, 0xC0, 0x70,
0x70, 0x07, 0xC0, 0x70, 0xF0, 0x1F, 0x80, 0x70, 0xF0, 0x1E, 0x00, 0x70, 0xE0, 0x3E, 0x00, 0x70,
0xE0, 0x78, 0x00, 0x70, 0xE0, 0xF0, 0x00, 0xF0, 0xE1, 0xE0, 0x00, 0xF0, 0xE3, 0xE0, 0x00, 0xE0,
0xE3, 0x80, 0x00, 0xE0, 0xE7, 0x80, 0x01, 0xE0, 0xEF, 0x00, 0x03, 0xE0, 0xEE, 0x00, 0x03, 0xC0,
0xFE, 0x00, 0x07, 0x80, 0x7C, 0x00, 0x1F, 0x00, 0x7C, 0x00, 0xFE, 0x00, 0x3D, 0xFF, 0xFC, 0x00,
0x39, 0xFF, 0xF0, 0x00, 0x70, 0xFE, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00
};

const unsigned char  dist_to_LPG [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0E, 0x20,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0E, 0x70,
0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0E, 0x38,
0x00, 0x01, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0E, 0x1C,
0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0E, 0x0C,
0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0F, 0x8C,
0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0F, 0x8C,
0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x0F, 0x8C,
0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C,
0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x60, 0x06, 0x00, 0x01, 0xFF, 0xFF, 0x8C,
0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x78, 0x07, 0x80, 0x01, 0xFF, 0xFF, 0x8C,
0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x1E, 0x01, 0xE0, 0x01, 0xFF, 0xFF, 0x8C,
0x7F, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFC, 0x00, 0x07, 0x80, 0x78, 0x01, 0xFF, 0xFF, 0x8C,
0x7F, 0xCF, 0x3F, 0xFF, 0xFF, 0xFE, 0x79, 0xFE, 0x00, 0x01, 0xE0, 0x1E, 0x01, 0xFF, 0xFF, 0x8C,
0x7F, 0x9F, 0xBF, 0xFF, 0xFF, 0xFC, 0xFD, 0xFE, 0x00, 0x00, 0x60, 0x06, 0x01, 0xFF, 0xFF, 0x8C,
0x3F, 0xBF, 0xDF, 0xFF, 0xFF, 0xFD, 0xFE, 0xFC, 0x00, 0x01, 0xE0, 0x1E, 0x01, 0xFF, 0xFF, 0x8C,
0x3F, 0x3F, 0xDF, 0xFF, 0xFF, 0xF9, 0xFE, 0xFC, 0x00, 0x07, 0x80, 0x78, 0x01, 0xFF, 0xFF, 0x8C,
0x0F, 0x7F, 0xDF, 0xFF, 0xFF, 0xFB, 0xFE, 0xFC, 0x00, 0x1E, 0x01, 0xE0, 0x01, 0xFF, 0xFF, 0x8C,
0x00, 0x3F, 0xCF, 0xFF, 0xFF, 0xF9, 0xFE, 0x70, 0x00, 0x78, 0x07, 0x80, 0x01, 0xFF, 0xFF, 0x8C,
0x00, 0x3F, 0xC0, 0x00, 0x00, 0x01, 0xFE, 0x00, 0x00, 0x60, 0x06, 0x00, 0x01, 0xFF, 0xFF, 0x8C,
0x00, 0x1F, 0x80, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C,
0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0xFC,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0xF8,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0
};

const unsigned char  average [] PROGMEM = {
0x00, 0x00, 0x07, 0xCE, 0x1F, 0xFE, 0x3F, 0xFE, 0x7C, 0x7C, 0x70, 0xFC, 0xF1, 0xFE, 0xE3, 0xEE,
0xE7, 0xCE, 0xEF, 0x8E, 0xFF, 0x1E, 0x7E, 0x1C, 0x7C, 0x7C, 0xFF, 0xF8, 0xFF, 0xF0, 0xE7, 0xC0
};

const unsigned char averagecons [] PROGMEM = {
0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x07, 0xCE, 0x01, 0xFF, 0xFE, 0x00, 0x00, 0x00,
0x1F, 0xFE, 0x01, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x3F, 0xFE, 0x01, 0xC0, 0x0E, 0x20, 0x00, 0x00,
0x7C, 0x7C, 0x01, 0xC0, 0x0E, 0x70, 0x00, 0x00, 0x70, 0xFC, 0x01, 0xC0, 0x0E, 0x38, 0x00, 0x00,
0xF1, 0xFE, 0x01, 0xC0, 0x0E, 0x1C, 0x00, 0x00, 0xE3, 0xEE, 0x01, 0xC0, 0x0E, 0x0C, 0x00, 0x00,
0xE7, 0xCE, 0x01, 0xC0, 0x0F, 0x8C, 0x00, 0x00, 0xEF, 0x8E, 0x01, 0xC0, 0x0F, 0x8C, 0x00, 0x00,
0xFF, 0x1E, 0x01, 0xC0, 0x0F, 0x8C, 0x00, 0x00, 0x7E, 0x1C, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00,
0x7C, 0x7C, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0xFF, 0xF8, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00,
0xFF, 0xF0, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0xE7, 0xC0, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00,
0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00,
0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00,
0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00,
0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0x8C, 0x00, 0x00,
0x00, 0x00, 0x01, 0xFF, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0xF8, 0x00, 0x00,
0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFE, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xC0, 0x00, 0x00
};
const unsigned char avspeed [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0x80, 0x00, 0x00,
0x00, 0x00, 0x00, 0x3F, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x6F, 0xF0, 0x00, 0x00,
0x00, 0x00, 0x01, 0xF0, 0x60, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x60, 0x3C, 0x00, 0x00,
0x07, 0xCE, 0x07, 0x80, 0x60, 0x3E, 0x00, 0x00, 0x1F, 0xFE, 0x0F, 0x00, 0x00, 0x7F, 0x00, 0x00,
0x3F, 0xFE, 0x0E, 0x30, 0x00, 0xE7, 0x00, 0x00, 0x7C, 0x7C, 0x1E, 0x38, 0x00, 0xC7, 0x80, 0x00,
0x70, 0xFC, 0x1C, 0x1E, 0x00, 0x03, 0x80, 0x00, 0xF1, 0xFE, 0x1C, 0x0F, 0x00, 0x03, 0x80, 0x00,
0xE3, 0xEE, 0x3C, 0x0F, 0xC0, 0x03, 0xC0, 0x00, 0xE7, 0xCE, 0x38, 0x07, 0xF0, 0x01, 0xC0, 0x00,
0xEF, 0x8E, 0x38, 0x03, 0xF8, 0x01, 0xC0, 0x00, 0xFF, 0x1E, 0x3F, 0x03, 0xF8, 0x0F, 0xC0, 0x00,
0x7E, 0x1C, 0x3F, 0x01, 0xF8, 0x0F, 0xC0, 0x00, 0x7C, 0x7C, 0x38, 0x01, 0xF0, 0x01, 0xC0, 0x00,
0xFF, 0xF8, 0x38, 0x00, 0xE0, 0x01, 0xC0, 0x00, 0xFF, 0xF0, 0x3C, 0x00, 0x00, 0x03, 0xC0, 0x00,
0xE7, 0xC0, 0x1C, 0x00, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x03, 0x80, 0x00,
0x00, 0x00, 0x1E, 0x30, 0x00, 0xC7, 0x80, 0x00, 0x00, 0x00, 0x0E, 0x70, 0x00, 0xE7, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xE0, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFE, 0x00, 0x00,
0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
const unsigned char dist [] PROGMEM = {
0x00, 0x39, 0x9C, 0x00, 0x00, 0x39, 0x9C, 0x00, 0x00, 0x71, 0x8E, 0x00, 0x00, 0x71, 0x8E, 0x00,
0x00, 0x71, 0x8E, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0xE1, 0x87, 0x00,
0x01, 0xC1, 0x83, 0x80, 0x01, 0xC1, 0x83, 0x80, 0x01, 0xC1, 0x83, 0x80, 0x03, 0x81, 0x81, 0xC0,
0x03, 0x81, 0x81, 0xC0, 0x03, 0x81, 0x81, 0xC0, 0x07, 0x00, 0x00, 0xE0, 0x07, 0x00, 0x00, 0xE0,
0x07, 0x01, 0x80, 0xE0, 0x0E, 0x01, 0x80, 0x70, 0x0E, 0x01, 0x80, 0x70, 0x0E, 0x01, 0x80, 0x70,
0x1C, 0x01, 0x80, 0x38, 0x1C, 0x01, 0x80, 0x38, 0x1C, 0x01, 0x80, 0x38, 0x38, 0x00, 0x00, 0x1C,
0x38, 0x00, 0x00, 0x1C, 0x38, 0x01, 0x80, 0x1C, 0x70, 0x01, 0x80, 0x0E, 0x70, 0x01, 0x80, 0x0E,
0x70, 0x01, 0x80, 0x0E, 0xE0, 0x01, 0x80, 0x07, 0xE0, 0x01, 0x80, 0x07, 0xE0, 0x01, 0x80, 0x07
};
const unsigned char Unleaded_fill_nozzle [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x07, 0xC0, 0x00, 0x00, 0x1F, 0xF0, 0x00,
0x00, 0x1F, 0xFF, 0xE0, 0x00, 0x1F, 0xFF, 0xF0, 0x00, 0x3F, 0xF8, 0x18, 0x00, 0x71, 0xF0, 0x00,
0x00, 0xEF, 0xE0, 0x00, 0x01, 0xD1, 0xC0, 0x08, 0x07, 0xE1, 0x80, 0x08, 0x07, 0x82, 0x00, 0x1C,
0x0E, 0xC6, 0x00, 0x1C, 0x18, 0x6C, 0x00, 0x3E, 0x10, 0x38, 0x00, 0x3E, 0x30, 0x00, 0x00, 0x1E,
0x30, 0x00, 0x00, 0x08, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
0x30, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
0x10, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char  logo [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xF8, 0x0F, 0x00, 0x0F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xFE, 0x0F, 0x00, 0x0F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xFF, 0x00, 0x00, 0x0F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0x1F, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x0F, 0x00, 0x78, 0x78, 0x0F, 0x80, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x0F, 0x00, 0x78, 0x78, 0x3F, 0xC0, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0x1E, 0x0F, 0x00, 0x0F, 0x00, 0x78, 0x78, 0x7F, 0xE0, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xFC, 0x0F, 0x00, 0x0F, 0x00, 0x78, 0x78, 0x78, 0xF0, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xFE, 0x0F, 0x00, 0x0F, 0xFC, 0x78, 0x78, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xFF, 0x0F, 0x3F, 0x8F, 0xFC, 0x78, 0x78, 0xFF, 0xF0, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0x0F, 0x8F, 0x3F, 0x8F, 0xFC, 0x78, 0x78, 0xFF, 0xF0, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0x07, 0x8F, 0x3F, 0x8F, 0x00, 0x78, 0x78, 0xFF, 0xF0, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0x07, 0x8F, 0x00, 0x0F, 0x00, 0x78, 0x78, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0x07, 0x8F, 0x00, 0x0F, 0x00, 0x78, 0x78, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0x0F, 0x8F, 0x00, 0x0F, 0x00, 0x7C, 0xF8, 0xF8, 0x60, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xFF, 0x0F, 0x00, 0x0F, 0x00, 0x7F, 0xF8, 0x7F, 0xE0, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xFE, 0x0F, 0x00, 0x0F, 0x00, 0x3F, 0xB8, 0x3F, 0xE0, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x0F, 0xF8, 0x0F, 0x00, 0x0F, 0x00, 0x1E, 0x38, 0x1F, 0x80, 0xF0, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0xFC, 0x01, 0x80, 0x00, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0xFC, 0x01, 0x80, 0x00, 0x1F, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
0x00, 0x60, 0x00, 0x00, 0x00, 0x18, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
0x00, 0x60, 0xD9, 0x8D, 0xC0, 0x30, 0x03, 0xC3, 0x73, 0x86, 0xE1, 0x86, 0x7C, 0x3C, 0x36, 0x00,
0x00, 0x60, 0xF9, 0x8F, 0xE0, 0x30, 0x07, 0xE3, 0xFF, 0xC7, 0xF1, 0x86, 0x7C, 0x7E, 0x3E, 0x00,
0x00, 0x60, 0xE1, 0x8E, 0x70, 0x30, 0x0E, 0x73, 0x9C, 0xC7, 0x39, 0x86, 0x30, 0xE7, 0x38, 0x00,
0x00, 0x60, 0xC1, 0x8C, 0x30, 0x30, 0x0C, 0x33, 0x18, 0xC6, 0x19, 0x86, 0x30, 0xC3, 0x30, 0x00,
0x00, 0x60, 0xC1, 0x8C, 0x30, 0x30, 0x0C, 0x33, 0x18, 0xC6, 0x19, 0x86, 0x30, 0xFF, 0x30, 0x00,
0x00, 0x60, 0xC1, 0x8C, 0x30, 0x30, 0x0C, 0x33, 0x18, 0xC6, 0x19, 0x86, 0x30, 0xC0, 0x30, 0x00,
0x00, 0x60, 0xC1, 0x8E, 0x70, 0x18, 0x2E, 0x73, 0x18, 0xC7, 0x39, 0x8E, 0x30, 0xE1, 0x30, 0x00,
0x00, 0x60, 0xC1, 0x8F, 0xE0, 0x1F, 0xE7, 0xE3, 0x18, 0xC7, 0xF1, 0xFE, 0x3C, 0x7F, 0x30, 0x00,
0x00, 0x60, 0xC1, 0x8D, 0xC0, 0x07, 0xC3, 0xC3, 0x18, 0xC6, 0xE0, 0xF6, 0x1C, 0x3E, 0x30, 0x00,
0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char FuelTank [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80,
0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8,
0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E,
0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E,
0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E,
0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E,
0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E,
0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0xEF, 0x00, 0x01, 0xE0, 0x00, 0x3C, 0x00, 0x0E,
0xFF, 0xF0, 0x07, 0xFE, 0x00, 0xFF, 0xC0, 0x1E, 0xFF, 0xFC, 0x0F, 0xFF, 0x81, 0xFF, 0xF0, 0x3E,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC,
0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0,
0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char petrolstationpump [] PROGMEM = {
0x03, 0xFF, 0xFC, 0x00, 0x03, 0xFF, 0xFC, 0x00, 0x03, 0xFF, 0xFC, 0x00, 0x03, 0x80, 0x1C, 0x40,
0x03, 0x80, 0x1C, 0xE0, 0x03, 0x80, 0x1C, 0x70, 0x03, 0x80, 0x1C, 0x38, 0x03, 0x80, 0x1C, 0x18,
0x03, 0x80, 0x1F, 0x18, 0x03, 0x80, 0x1F, 0x18, 0x03, 0x80, 0x1F, 0x18, 0x03, 0xFF, 0xFF, 0x18,
0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18,
0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18,
0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18, 0x03, 0xFF, 0xFF, 0x18,
0x03, 0xFF, 0xFD, 0xF8, 0x03, 0xFF, 0xFD, 0xF0, 0x03, 0xFF, 0xFC, 0x00, 0x03, 0xFF, 0xFC, 0x00,
0x1F, 0xFF, 0xFF, 0x80, 0x1F, 0xFF, 0xFF, 0x80, 0x1F, 0xFF, 0xFF, 0x80, 0x1F, 0xFF, 0xFF, 0x80
};

const unsigned char speedometer [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xE0, 0x00, 0x00, 0x7F, 0xFE, 0x00, 0x00, 0xFF, 0xFF, 0x00,
0x03, 0xFD, 0xBF, 0xC0, 0x07, 0xC1, 0x83, 0xE0, 0x0F, 0x01, 0x80, 0xF0, 0x1E, 0x01, 0x80, 0xF8,
0x3C, 0x00, 0x01, 0xFC, 0x38, 0xC0, 0x03, 0x9C, 0x78, 0xE0, 0x03, 0x1E, 0x70, 0x78, 0x00, 0x0E,
0x70, 0x3C, 0x00, 0x0E, 0xF0, 0x3F, 0x00, 0x0F, 0xE0, 0x1F, 0xC0, 0x07, 0xE0, 0x0F, 0xE0, 0x07,
0xFC, 0x0F, 0xE0, 0x3F, 0xFC, 0x07, 0xE0, 0x3F, 0xE0, 0x07, 0xC0, 0x07, 0xE0, 0x03, 0x80, 0x07,
0xF0, 0x00, 0x00, 0x0F, 0x70, 0x00, 0x00, 0x0E, 0x70, 0x00, 0x00, 0x0E, 0x78, 0xC0, 0x03, 0x1E,
0x39, 0xC0, 0x03, 0x9C, 0x3F, 0x80, 0x01, 0xFC, 0x1F, 0xFF, 0xFF, 0xF8, 0x0F, 0xFF, 0xFF, 0xF0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char snowflake [] PROGMEM = {
0x01, 0x80, 0x07, 0xE0, 0x13, 0xC8, 0xD1, 0x8B, 0xF9, 0x9F, 0x39, 0x9C, 0xFF, 0xFF, 0x07, 0xE0,
0x07, 0xE0, 0xFF, 0xFF, 0x39, 0x9C, 0xF9, 0x9F, 0xD1, 0x8B, 0x13, 0xC8, 0x07, 0xE0, 0x01, 0x80
};

void setup()
{
  pinMode(10, INPUT); // Button 2
  pinMode(11, INPUT); // Button 1

  pinMode(vss_pin, INPUT);
  pinMode(LPG_pin, INPUT);
  pinMode(ignition_pin, INPUT);
  pinMode(unleaded_pin, INPUT);

  // below recalls the values stored in case of power loss
  traveled_distance = EEPROM.readFloat(0);
  traveled_distance2 = EEPROM.readFloat (5);
  used_LPG = EEPROM.readFloat (10);
  used_LPG2 = EEPROM.readFloat(15);
  LPG_in_tank = EEPROM.readFloat(20);
  seconds_passed = EEPROM.readFloat(25);
  used_Unleaded = EEPROM.readFloat(30);
  traveled_distance3 = EEPROM.readFloat (35);
  used_Unleaded2 = EEPROM.readFloat(45);
  traveled_distance4 = EEPROM.readFloat (50);
  LPG1 = EEPROM.readByte (40);
  LPG2 = EEPROM.readByte (41);
  LPG3 = EEPROM.readByte (42);
  LPG4 = EEPROM.readByte (43);
  LPG_injector_flow = (LPG1 * 1000 + LPG2 * 100 + LPG3 * 10 + LPG4) * 1e-11;


  noInterrupts();
  // set and initialize the TIMER1
    TCCR1A = 0; // set entire TCCR1A register to 0
    TCCR1B = 0; // set entire TCCR1B register to 0
    TCCR1B |= (1 << CS12);//prescaler 256 --> Increment time = 256/16.000.000 = 16us
    TIMSK1 |= (1 << TOIE1);
    TCNT1 = 3036; // counter initial value so as to overflow every 1sec

  attachPCINT(digitalPinToPinChangeInterrupt(ignition_pin), ignitionSignal, CHANGE);

  interrupts();
  delay(10);
  // Serial.begin(9600);
}

void loop()
{
// When the ignition switch is turned, executes the next two ifs
  if (ignition == true and digitalRead(9) == LOW)
  {
    // Serial.println("pin9_LOW");
    // Serial.println(menunumber);
    detachInterrupt(digitalPinToInterrupt(vss_pin));
    detachInterrupt(digitalPinToInterrupt(LPG_pin));
    detachPCINT(digitalPinToPinChangeInterrupt(unleaded_pin));
    delay(50);
    ignition = false;
    if (menunumber == 11)
    {
          EEPROM.writeByte(40, LPG1); //stores the new LPG coef.
          EEPROM.writeByte(41, LPG2);
          EEPROM.writeByte(42, LPG3);
          EEPROM.writeByte(43, LPG4);
       LPG_injector_flow = (LPG1 * 1000 + LPG2 * 100 + LPG3 * 10 + LPG4) * 1e-11;
       inst_disp = true;
       menunumber = 0;
    }
    if (menunumber == 12) // same as previous for "Time Set" menu
    {
      DateTime dt = rtc.now();
      s = dt.second();
      if (m != m1) s = (((millis() - counter)/1000))%60;
      else s = dt.second(), m = dt.minute();
      rtc.adjust(DateTime(dt.year(), dt.month(), dt.day(), h, m, s));
      ignoreRelease = true;
      lastButtonState2 = LOW;
      menunumber = 8;
    }
    // when the ignition switched off it stores the values to the EEPROM
    EEPROM.writeFloat (0, traveled_distance);
    EEPROM.writeFloat (5, traveled_distance2);
    EEPROM.writeFloat (10, used_LPG);
    EEPROM.writeFloat (15, used_LPG2);
    EEPROM.writeFloat (20, LPG_in_tank);
    EEPROM.writeFloat (25, seconds_passed);
    EEPROM.writeFloat (30, used_Unleaded);
    EEPROM.writeFloat (35, traveled_distance3);
    EEPROM.writeFloat (45, used_Unleaded2);
    EEPROM.writeFloat (50, traveled_distance4);

    display.ssd1306_command(SSD1306_DISPLAYOFF);
    //  Serial.println("sleep");
    sleep_enable(); // enables the sleep mode
    set_sleep_mode(SLEEP_MODE_PWR_DOWN); // set the sleep mode
    cli();
    sleep_bod_disable(); // disables the brown out detector to consume less power while sleeping
    sei();
    sleep_mode(); // microcontroller goes to sleep
  }
  // when it wakes up continues from here -- also the first time we turn the ignition key to ON starts from here
  if (ignition == true && digitalRead(9) == HIGH)
  {
    ignition = false;    // this variable is needed in order to run once the code inside this if
    logohold = millis(); // hold the LOGO screen on, for 2 sec
    inst_disp = true;
    display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
    display.clearDisplay();

    // initial logo -- display.drawBitmap(position x, position y, bitmap_code, width, height, color)
    display.drawBitmap(0, 0,  logo, 128, 64, WHITE);

    // initial logo -- display text without graphic
    display.setCursor(15, 10);
    display.setTextSize(2);
    display.print("FORESTER");

    display.display();

    attachInterrupt(digitalPinToInterrupt(vss_pin), distance, RISING); // attaches the interrupt which related to the VSS signal
    attachInterrupt(digitalPinToInterrupt(LPG_pin), LPG_injector_time, CHANGE); // interrupt for LPG injector signal
    attachPCINT(digitalPinToPinChangeInterrupt(unleaded_pin), UnleadedTime, CHANGE); // petrol injector signal input and interrupt
    while (millis() - logohold < 3000) ;

  }

  // every 5sec calculates average LPG consumption, remaining distance accordingly to the calculated remaining fuel in tank, average speed and average Unleaded cons.
  if (millis() % 5000 < 50)
  {
    avg_LPG_consumption = 100 * used_LPG2 / traveled_distance2;
    distance_to_LPGstation = 100 * LPG_in_tank / avg_LPG_consumption;
    avg_speed = (traveled_distance3 / seconds_passed) * 3600;
    average_L_100km_Unlead = 100 * used_Unleaded2 / traveled_distance2;
  }

// For the short and long press function I consulted: http://jmsarduino.blogspot.gr/2009/05/click-for-press-and-hold-for-b.html
// There are many differences though
// "button 1" -- only  SHORT PRESS function -- changes occur on press, because there is no LONG PRESS function
  if (digitalRead(11) != buttonState) {
    buttonState = digitalRead(11);
    // Serial.println("pin11_low");
    if (buttonState == LOW)
    {
      // changes the display indications forwards
      if (menunumber <= menunumbermax) {
        if (menunumber == menunumbermax) menunumber = 0;
        else menunumber += 1;
      }
      //if we are at the "Time Set" menu it changes the Hour
      if (menunumber == 12) 
      {
        if (h < 23) h += 1, counter = millis();
        else h = 0, counter = millis();
      }
      // if we are at the "LPG Coef." menu it changes the LPG_injector_flow digits
      if (menunumber == 11 && digitLPG == 1){
        if (LPG1 < 9) LPG1 += 1, counter = millis();
        else LPG1 = 0, counter = millis();
      }
      if (menunumber == 11 && digitLPG == 2){
        if (LPG2 < 9) LPG2 += 1, counter = millis();
        else LPG2 = 0, counter = millis();
      }
      if (menunumber == 11 && digitLPG == 3){
        if (LPG3 < 9) LPG3 += 1, counter = millis();
        else LPG3 = 0, counter = millis();
      }
      if (menunumber == 11 && digitLPG == 4){
        if (LPG4 < 9) LPG4 += 1,  counter = millis();
        else LPG4 = 0, counter = millis();
      }
    }
  }

  ////////// "button 2" functions /////////////////
  buttonState2 = digitalRead(10);
  if (buttonState2 == LOW && lastButtonState2 == HIGH) lastDebounceTime = millis(); //keeps the time that button2 pressed

  if (buttonState2 == HIGH && lastButtonState2 == LOW)
  {
    if (ignoreRelease == false) // "button 2" SHORT PRESS functions -- on release
    {
      if (menunumber <= menunumbermax)
      {
        if (menunumber == 0) menunumber = menunumbermax;
        else menunumber = menunumber - 1;
      }
      if (menunumber == 12)
      {
        if (m < 59) m = m+1, counter = millis();
        else m = 0, counter = millis();
      }
      if (menunumber == 11) // LPG coef. setting menu -- "button 2" short press changes the position of the cursor
      {
        pos += 18;
        digitLPG += 1;
        counter = millis();
        if (digitLPG == 5)
        {
          pos = 0;
          digitLPG = 1;
        }
      }
    }
    else ignoreRelease = false;
  }
  //////////////////// "button 2" LONG PRESS functions /////////////////////////////////////////////////////
  if (digitalRead(10) == HIGH) displaychange = true;
  if (buttonState2 == LOW && (millis() - lastDebounceTime) > 3000 && displaychange == true) // below are the long press functions for button 2
  {
    if (menunumber == 0) menunumber = 11, counter = millis(), counter2 = millis(), displaychange = false, digitLPG = 1; //goes to the "LPG Coef." menu
    if (menunumber == 1) traveled_distance2 = 0, used_LPG2 = 0, avg_LPG_consumption = 0, used_Unleaded2 = 0;// average LPG consumption and average Unleaeded cons. reset
    if (menunumber == 3) traveled_distance3 = 0, seconds_passed = 0, avg_speed = 0; // average speed reset
    if (menunumber == 4) traveled_distance = 0; //traveled Distance = 0
    if (menunumber == 6) used_LPG = 0; // total LPG litres = 0
    if (menunumber == 7) LPG_in_tank = Full_tank; // LPG tank reset to full
    if (menunumber == 8) menunumber = 12, counter = millis(), counter2 = millis(), timeRead = true, displaychange = false; //goes to the "Time Setting" menu
    if (menunumber == 9) traveled_distance2 = 0, used_LPG2 = 0, avg_LPG_consumption = 0, used_Unleaded2 = 0; // same with menunumber = 1
    if (menunumber == 10) used_Unleaded = 0; // total unleaded fuel reset

    ignoreRelease = true;
  }
  lastButtonState2 = buttonState2;

// below are the misc screens
switch (menunumber)
{
    case 0:
cons1:  display.clearDisplay();
        if(inst_disp == true) displaychange = false, inst_disp = false, digitLPG = 0, pos = 0;
        display.setTextColor(WHITE);
        display.drawBitmap(0, 0,  petrolstationpump, 32, 32, WHITE);
        display.setCursor(40, 0);
        display.setTextSize(1);
        display.print(F("LPG"));
        display.setCursor(40,12);
        display.setTextSize(2);
        if (speed > 2) display.print(F("l/100km"));
        else display.print(F("l/h")); //when the car is stopped displays the instant consumption in l/h
        display.setCursor(0,36);
        display.setTextSize(4);
        if(instant_LPG_consumption > 99.9) display.print(F("--.-"));
        else display.print(instant_LPG_consumption,1);
        display.display();
    break;

    case 1:
        display.clearDisplay();
        display.setTextColor(WHITE);
        display.drawBitmap(0, 0,  averagecons, 64, 32, WHITE);
        display.setCursor(54, 0);
        display.setTextSize(1);
        display.print(F("LPG"));
        display.setCursor(54,15);
        display.setTextSize(2);
        display.print(F("l/100"));
        display.setCursor(0, 36);
        display.setTextSize(4);
        if(isnan(avg_LPG_consumption)|| isinf(avg_LPG_consumption)) display.print(F("---"));
        else display.print(avg_LPG_consumption, 1);
        display.display();
    break;

    case 2:
        display.clearDisplay();
        display.setTextColor(WHITE);
        display.drawBitmap(49, 1,  speedometer, 32, 32, WHITE);
        display.setCursor(0,36);
        display.setTextSize(4);
        display.print(speed, 0);
        display.setCursor(84, 34);
        display.setTextSize(2);
        display.print(F("km"));
        display.setCursor(104, 37);
        display.setTextSize(3);
        display.print(F("/"));
        display.setCursor(115, 48);
        display.setTextSize(2);
        display.print(F("h"));
        display.display();
    break;

    case 3:
        display.clearDisplay();
        display.setTextColor(WHITE);
        display.drawBitmap(31, 0,  avspeed, 64, 32, WHITE);
        display.setCursor(0, 36);
        display.setTextSize(4);
        display.print(avg_speed, 0);
        display.setCursor(84, 34);
        display.setTextSize(2);
        display.print(F("km"));
        display.setCursor(104, 37);
        display.setTextSize(3);
        display.print(F("/"));
        display.setCursor(115, 48);
        display.setTextSize(2);
        display.print(F("h"));
        display.display();
    break;

    case 4:
        display.clearDisplay();
        display.setTextColor(WHITE);
        display.drawBitmap(48, 0,  dist, 32, 32, WHITE);
        display.setCursor(88,18);
        display.setTextSize(2);
        display.print(F("km"));
        display.setCursor(0, 36);
        display.setTextSize(4);
        display.print(traveled_distance, 1);
        display.display();
    break;

    case 5:
        display.clearDisplay();
        display.setTextColor(WHITE);
        display.drawBitmap(0, 0,  dist_to_LPG, 128, 32, WHITE);
        display.setCursor(0, 36);
        display.setTextSize(4);
        if(distance_to_LPGstation < 10 ||  isnan(distance_to_LPGstation) || isinf(distance_to_LPGstation) ) display.print(F("---"));
        else display.print(distance_to_LPGstation,0);
        display.setTextSize(2);
        display.setCursor(90,48);
        display.print(F("km"));
        display.display();
    break;

    case 6:
        display.clearDisplay();
        display.setTextColor(WHITE);
        display.drawBitmap(0, 0,  leaf, 32, 32, WHITE);
        display.setCursor(40, 2);
        display.setTextSize(1);
        display.print(F("Total"));
        display.setCursor(40, 12);
        display.setTextSize(2);
        display.print(F("LPG"));
        display.setCursor(0, 36);
        display.setTextSize(4);
        display.print(used_LPG,1);
        display.print(F("l"));
        display.display();
    break;

    case 7:
        display.clearDisplay();
        display.setTextColor(WHITE);
        display.drawBitmap(31, 0,  FuelTank, 64, 32, WHITE);
        display.setCursor(0, 36);
        display.setTextSize(4);
        if (LPG_in_tank <= 0 ) display.print(F("0.0"));
        else display.print(LPG_in_tank,1);
        display.setTextSize(3);
        display.setCursor(105,43);
        display.print(F("l"));
        display.display();
    break;

    case 8:
      temp1:
        if(inst_disp == true) displaychange = false, inst_disp = false;
        display.clearDisplay();
        display.setTextColor(WHITE);
        sensors.requestTemperatures();
        float tempC = sensors.getTempCByIndex(0);
//        printTemperature();
//        display.drawFastHLine(0, 28, 128, WHITE);
//        display.drawFastHLine(0, 29, 128, WHITE);
//        display.setCursor(7, 36);
//        display.setTextSize(4);
//        printTime();

        display.setCursor(40, 0);
        display.setTextSize(4);
        display.print(tempC, 1);
        display.setTextSize(1);
        display.setCursor(16, 24);
        display.print(F("TEMP. ZEWNETRZNA"));

        if(steinhart < 3.5)
          {
          display.drawBitmap(0, 3,  snowflake, 16, 16, WHITE);
          }
        display.display();
    break;

    case 9:
        display.clearDisplay();
        display.setTextColor(WHITE);
        display.drawBitmap(0, 8,  average, 16, 16, WHITE);
        display.drawBitmap(17, 0,  Unleaded_fill_nozzle, 32, 32, WHITE);
        display.setCursor(54,13);
        display.setTextSize(2);
        display.print(F("l/100"));
        display.setCursor(0, 36);
        display.setTextSize(4);
        if(isnan(average_L_100km_Unlead)|| isinf(average_L_100km_Unlead)) display.print(F("---"));
        else display.print(average_L_100km_Unlead, 1);
        display.display();
    break;

    case 10:
        display.clearDisplay();
        display.setTextColor(WHITE);
        display.drawBitmap(96, 0,  Unleaded_fill_nozzle, 32, 32, WHITE); //(x,y, name, DX, DY, color)
        display.setTextSize(1);
        display.setCursor(0, 0);
        display.print(F("Total"));
        display.setTextSize(2);
        display.setCursor(0, 10);
        display.print(F("Unleaded"));
        display.setCursor(0, 36);
        display.setTextSize(4);
        display.print(used_Unleaded,1);
        display.setTextSize(3);
        display.setCursor(105,43);
        display.print(F("l"));
        display.display();
      break;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// the following are secondary displays and activated only in case we want to set the LPG Coef.(case 11) or the Time (case 12)

    case 11: // LPG Coef. Setting menu
        display.clearDisplay();
        display.setTextColor(WHITE);
        display.setCursor(0,9);
        display.setTextSize(2);
        display.print(F("LPG Coef."));
        display.drawFastHLine(0, 28, 128, WHITE);
        display.drawFastHLine(0, 29, 128, WHITE);
        display.setCursor(0,36);
        display.setTextSize(3);

        display.print(LPG1);
        display.print(LPG2);
        display.print(LPG3);
        display.print(LPG4);

        display.setCursor(pos,42);
        display.print(F("_"));
        if (digitalRead(10) == HIGH) counter2 = millis(), displaychange = true; //we must release "button 2" at least once in order to be able to go back to instant LPG consuption
        if ((digitalRead(10) == LOW && millis() - counter2 > 3000 && displaychange == true) || millis() - counter > 10000){
            EEPROM.writeByte(40, LPG1); //stores the new LPG coef.
            EEPROM.writeByte(41, LPG2);
            EEPROM.writeByte(42, LPG3);
            EEPROM.writeByte(43, LPG4);
         LPG_injector_flow = (LPG1 * 1000 + LPG2 * 100 + LPG3 * 10 + LPG4) * 1e-11;
         ignoreRelease = true;
         inst_disp = true;
         lastButtonState2 = LOW;
         menunumber = 0;
         goto cons1;
        }
        display.display();
    break;

    case 12: //RTC set
        display.clearDisplay();
        display.setTextColor(WHITE);
        display.setCursor(0,9);
        display.setTextSize(2);
        display.print(F("Time Set"));
        display.drawFastHLine(0, 28, 128, WHITE);
        display.drawFastHLine(0, 29, 128, WHITE);

        if (timeRead == true){
        DateTime dt = rtc.now();
        h = dt.hour();
        m = dt.minute();
        m1 = dt.minute();
        timeRead = false;
        }
        display.setCursor(7, 36);
        display.setTextSize(4);
        char sdt[15];
        sprintf(sdt, "%02d:%02d", h, m);
        display.print(sdt);
        display.display();

        if(digitalRead(10) == HIGH) counter2 = millis(), displaychange = true; //we must release the button 2 at least once in order to be able to go back to Temp and Time screen
        if((digitalRead(10) == LOW && millis() - counter2 > 3000 && displaychange == true) || millis() - counter > 59000){
        DateTime dt = rtc.now();
        s = dt.second();
        if (m != m1) s = (((millis() - counter)/1000))%60;
        else s = dt.second(), m = dt.minute();
        rtc.adjust(DateTime(dt.year(), dt.month(), dt.day(), h, m, s));
        inst_disp = true;
        ignoreRelease = true;
        lastButtonState2 = LOW;
        menunumber = 8;
        }
    break;
      }
      //Serial.println("koniec case");
  }

ISR(TIMER1_OVF_vect) //TIMER1 overflow interrupt -- occurs every 1sec --
{
  instantSpeed();

  LPG_Consumption();
  LPG_injector_open_duration = 0;

  unleadedConsumption();
  unleadinj_Open_Duration = 0;

  seconds_passed++;
  vss_pulses = 0;

  TCNT1 = 3036;
}

void distance()
{
  vss_pulses++;
  traveled_distance += vss_pulse_distance;
  traveled_distance2 += vss_pulse_distance;
  traveled_distance3 += vss_pulse_distance;
  traveled_distance4 += vss_pulse_distance;
  // we calculate 3 times the same thing in order to reset the distance, the average cons. and average speed independently
}

void instantSpeed()
{
  distance_per_sec = vss_pulse_distance * vss_pulses;
  speed = (distance_per_sec * 3600);
}

// The following routine is giving the way to calculate the total time that LPG injector open during the 1sec interval
void LPG_injector_time()
{
  injTime2 = micros();
  if ((injTime2 - injTime1) < 5000 && (injTime2 - injTime1) > 4)
  {
    LPG_injector_open_duration = LPG_injector_open_duration + injTime2 - injTime1;
  }
  injTime1 = injTime2;
}


void LPG_Consumption()
{
  if (speed > 2 ) instant_LPG_consumption = (100 * ((LPG_injector_open_duration * LPG_injector_flow) * 3600)) / speed;

  else  instant_LPG_consumption = LPG_injector_open_duration * LPG_injector_flow * 3600; // when the car stops calculates the instant consumption in l/h

  used_LPG = used_LPG + (LPG_injector_open_duration * LPG_injector_flow);
  used_LPG2 = used_LPG2 + (LPG_injector_open_duration * LPG_injector_flow);
  LPG_in_tank = LPG_in_tank - (LPG_injector_open_duration * LPG_injector_flow);
}

void UnleadedTime() // it is called every time a change occurs at the gasoline injector signal and calculates gasoline injector opening time, during the 1sec interval
{
  if (digitalRead(12) == LOW)
  {
    unleadTime1 = micros();
  }
  if (digitalRead(12) == HIGH)
  {
    unleadTime2 = micros();
  }
  if (unleadTime2 > unleadTime1)
  {
    if ((unleadTime2 - unleadTime1) > 500 && (unleadTime2 - unleadTime1) < 12000)
    // my injectors do not open for longer than 12ms = 12000us (you can change this if you want)
    // some conditions to avoid false readings because of noise
    {
      unleadinj_Open_Duration = unleadinj_Open_Duration + (unleadTime2 - unleadTime1);
      //total useconds that the gasoline injector opens throughout 1sec
    }
  }
}

void unleadedConsumption()
{
  used_Unleaded = used_Unleaded + (unleadinj_Open_Duration * unleadedFlow);
  used_Unleaded2 = used_Unleaded2 + (unleadinj_Open_Duration * unleadedFlow);
}


void ignitionSignal() // this is called everytime the ingintion signal changes -- if the microcontroller is in sleep mode, it will wake up
{
  ignition = !ignition;
}

void printTime()
{
  DateTime dt = rtc.now();
  char sdt[15];
  sprintf(sdt, "%02d:%02d", dt.hour(), dt.minute());
  display.print(sdt);
}

void printTemperatureSensors(DeviceAddress deviceAddress)
{
  // method 1 - slower
  //Serial.print("Temp C: ");
  //Serial.print(sensors.getTempC(deviceAddress));
  //Serial.print(" Temp F: ");
  //Serial.print(sensors.getTempF(deviceAddress)); // Makes a second call to getTempC and then converts to Fahrenheit

  // method 2 - faster
  float tempC = sensors.getTempC(deviceAddress);
  if (tempC == DEVICE_DISCONNECTED_C)
  {
    Serial.println("Error: Could not read temperature data");
    return;
  }
  Serial.print("Temp C: ");
  Serial.print(tempC);
  Serial.print(" Temp F: ");
  Serial.println(DallasTemperature::toFahrenheit(tempC)); // Converts tempC to Fahrenheit
}

void printTemperature()
{
            for (i = 0; i< NUMSAMPLES; i++) {
             samples[i] = analogRead(THERMISTORPIN);
             delay(10);
            }
        // average all the samples out

              thermReading = 0;
              for (i = 0; i< NUMSAMPLES; i++) {
                 thermReading += samples[i];
              }
              thermReading / = NUMSAMPLES;

        // convert the value to resistance

        thermReading = 1023 / thermReading - 1;
        thermReading = SERIESRESISTOR / thermReading;

        steinhart = thermReading / THERMISTORNOMINAL;     // (R/Ro)
        steinhart = log(steinhart);                       // ln(R/Ro)
        steinhart / = BCOEFFICIENT;                        // 1/B * ln(R/Ro)
        steinhart += 1.0 / (TEMPERATURENOMINAL + 273.15); // + (1/To)
        steinhart = 1.0 / steinhart;                      // Invert
        steinhart -= 273.15;                              // convert to C
        //steinhart = (steinhart * 9.0)/ 5.0 + 32.0;      // Uncomment if you want to convert Celcius to Fahrenheit

        if (steinhart <0 && steinhart > -0.6){ //this is in order not to display "-0"
          steinhart = 0;
          }
        if(steinhart >= 9.5 || (steinhart <= -0.6 && steinhart > -9.6)) postemp = 62; //postemp: the x position of the cursor is depended on how many characters the temp has (1, 2 or 3)
        if(steinhart < 9.5 && steinhart > -0.6) postemp = 80;
        if(steinhart <= -9.6) postemp = 44;
        display.setCursor(postemp,0);
        display.setTextSize(3);
        display.print(steinhart, 0);
        display.setCursor(100, -2);
        display.setTextSize(1);
        display.print(F("o"));
        display.setCursor(108, 0);
        display.setTextSize(3);
        display.print(F("C"));
}